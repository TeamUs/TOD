# -*- coding: utf-8 -*-
"""04_data_files_Павшок_Артём_ПИ22-4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vqfyUqcJVYZLkA-NB0Nw1KhhOCn8O2Y3

# Форматы данных (1)

Материалы:
* Макрушин С.В. "Лекция 4: Форматы данных"
* https://docs.python.org/3/library/json.html
* https://docs.python.org/3/library/pickle.html
* https://www.crummy.com/software/BeautifulSoup/bs4/doc.ru/bs4ru.html
* Уэс Маккини. Python и анализ данных

## Задачи для совместного разбора

1. Вывести все адреса электронной почты, содержащиеся в адресной книге `addres-book.json`
"""

import json

with open('addres-book.json', 'r') as f:
    data = json.load(f)

for contact in data:
    email = contact['email']
    print(email)

"""2. Вывести телефоны, содержащиеся в адресной книге `addres-book.json`"""

import json

with open('addres-book.json', 'r') as f:
    data = json.load(f)

for contact in data:
    phones = contact['phones']
    print(phones)

"""**3**. По данным из файла `addres-book-q.xml` сформировать список словарей с телефонами каждого из людей. """

import xml.etree.ElementTree as ET

tree = ET.parse('addres-book-q.xml')
root = tree.getroot()

addresses = []

for country in root.findall('country'):
    for address in country.findall('address'):
        phones = []
        for phone in address.find('phones').findall('phone'):
            phones.append({phone.get('type'): phone.text})
        addresses.append({'name': address.find('name').text,
                          'phones': phones})

print(addresses)

"""## Лабораторная работа №4

### JSON

1.1 Считайте файл `contributors_sample.json`. Воспользовавшись модулем `json`, преобразуйте содержимое файла в соответствующие объекты python. Выведите на экран информацию о первых 3 пользователях.
"""

import json

with open('contributors_sample.json') as f:
    data = json.load(f)

for user in data[:3]:
    print(f"Username: {user['username']}")
    print(f"Name: {user['name']}")
    print(f"Sex: {user['sex']}")
    print(f"Address: {user['address']}")
    print(f"Mail: {user['mail']}")
    print(f"Jobs: {', '.join(user['jobs'])}")
    print(f"ID: {user['id']}")
    print()

"""1.2 Выведите уникальные почтовые домены, содержащиеся в почтовых адресах людей"""

import json

with open('contributors_sample.json', 'r') as f:
    contributors = json.load(f)

domains = set()

for contributor in contributors:
    email_domain = contributor['mail'].split('@')[-1]
    domains.add(email_domain)

print(domains)

"""1.3 Напишите функцию, которая по `username` ищет человека и выводит информацию о нем. Если пользователь с заданным `username` отсутствует, возбудите исключение `ValueError`"""

import json

def find_user(username):
    with open('contributors_sample.json') as f:
        data = json.load(f)
        for user in data:
            if user['username'] == username:
                return user
        raise ValueError('User not found')

# пример использования
try:
    user = find_user('uhebert')
    print(user)
except ValueError as e:
    print(e)

"""1.4 Посчитайте, сколько мужчин и женщин присутсвует в этом наборе данных."""

import json

with open('contributors_sample.json') as f:
    data = json.load(f)

male_count = 0
female_count = 0

for person in data:
    if person['sex'] == 'M':
        male_count += 1
    elif person['sex'] == 'F':
        female_count += 1

print("Количество мужчин: ", male_count)
print("Количество женщин: ", female_count)

"""1.5 Создайте `pd.DataFrame` `contributors`, имеющий столбцы `id`, `username` и `sex`."""

import pandas as pd
import json

# загружаем данные из файла
with open('contributors_sample.json') as f:
    data = json.load(f)

# создаем список словарей
contributors_list = []
for contributor in data:
    contributors_list.append({'id': contributor['id'], 'username': contributor['username'], 'sex': contributor['sex']})

# создаем DataFrame
contributors = pd.DataFrame(contributors_list, columns=['id', 'username', 'sex'])

# выводим на экран
print(contributors.head())

"""1.6 Загрузите данные из файла `recipes_sample.csv` (__ЛР2__) в таблицу `recipes`. Объедините `recipes` с таблицей `contributors` с сохранением строк в том случае, если информация о человеке отсутствует в JSON-файле. Для скольких человек информация отсутствует? """

import pandas as pd

# загрузка данных из файлов
recipes = pd.read_csv('recipes_sample.csv')
contributors = pd.read_json('contributors_sample.json')

# объединение таблиц
merged = pd.merge(recipes, contributors[['id', 'username']], left_on='contributor_id', right_on='id', how='left')

# подсчет количества строк, в которых информация о человеке отсутствует
missing_count = merged['username'].isna().sum()

print(f'Количество строк, в которых информация о человеке отсутствует: {missing_count}')

"""### pickle

2.1 На основе файла `contributors_sample.json` создайте словарь следующего вида: 
```
{
    должность: [список username людей, занимавших эту должность]
}
```
"""

import json

# Считываем данные из JSON-файла
with open('contributors_sample.json', 'r') as f:
    contributors = json.load(f)

# Создаем словарь
positions = {}
for person in contributors:
    for job in person['jobs']:
        positions.setdefault(job, []).append(person['username'])

# Выводим результаты
for job, users in positions.items():
    print(job + ':', users)

"""2.2 Сохраните результаты в файл `job_people.pickle` и в файл `job_people.json` с использованием форматов pickle и JSON соответственно. Сравните объемы получившихся файлов. При сохранении в JSON укажите аргумент `indent`."""

import json
import pickle

# Считываем данные из JSON-файла
with open('contributors_sample.json', 'r') as f:
    contributors = json.load(f)

# Создаем словарь
positions = {}
for person in contributors:
    for job in person['jobs']:
        positions.setdefault(job, []).append(person['username'])

# Сохраняем в файл формата pickle
with open('job_people.pickle', 'wb') as f:
    pickle.dump(positions, f)

# Сохраняем в файл формата JSON с отступами
with open('job_people.json', 'w') as f:
    json.dump(positions, f, indent=2)

"""2.3 Считайте файл `job_people.pickle` и продемонстрируйте, что данные считались корректно. """

import pickle

# Читаем данные из файла job_people.pickle
with open('job_people.pickle', 'rb') as f:
    job_people = pickle.load(f)

# Выводим результаты
for job, users in job_people.items():
    print(job + ':', users)

"""### XML

3.1 По данным файла `steps_sample.xml` сформируйте словарь с шагами по каждому рецепту вида `{id_рецепта: ["шаг1", "шаг2"]}`. Сохраните этот словарь в файл `steps_sample.json`
"""

import xml.etree.ElementTree as ET
import json

# Чтение XML-файла
tree = ET.parse('steps_sample.xml')
root = tree.getroot()

# Создание словаря с шагами по каждому рецепту
steps_dict = {}
for recipe in root.findall('recipe'):
    recipe_id = recipe.find('id').text
    steps = []
    for step in recipe.find('steps').findall('step'):
        steps.append(step.text)
    steps_dict[recipe_id] = steps

# Сохранение словаря в JSON-файл
with open('steps_sample.json', 'w') as f:
    json.dump(steps_dict, f)

"""3.2 По данным файла `steps_sample.xml` сформируйте словарь следующего вида: `кол-во_шагов_в_рецепте: [список_id_рецептов]`"""

import xml.etree.ElementTree as ET

# Парсинг XML-файла
tree = ET.parse('steps_sample.xml')

# Получение корневого элемента
root = tree.getroot()

# Создание словаря для хранения количества шагов в рецепте и списка рецептов
steps_count = {}

# Итерация по всем рецептам
for recipe in root.findall('recipe'):
    # Получение количества шагов
    steps = recipe.findall('steps/step')
    count = len(steps)
    
    # Добавление рецепта в соответствующий список
    if count not in steps_count:
        steps_count[count] = []
    steps_count[count].append(recipe.find('id').text)

# Вывод результата
print(steps_count)

"""3.3 Получите список рецептов, в этапах выполнения которых есть информация о времени (часы или минуты). Для отбора подходящих рецептов обратите внимание на атрибуты соответствующих тэгов."""

import xml.etree.ElementTree as ET

tree = ET.parse('steps_sample.xml')
root = tree.getroot()

recipes_with_time = []

for recipe in root.findall('recipe'):
    for step in recipe.find('steps').findall('step'):
        if 'has_minutes' in step.attrib or 'has_degrees' in step.attrib:
            recipes_with_time.append(recipe.find('id').text)
            break

print(recipes_with_time)

"""3.4 Загрузите данные из файла `recipes_sample.csv` (__ЛР2__) в таблицу `recipes`. Для строк, которые содержат пропуски в столбце `n_steps`, заполните этот столбец на основе файла  `steps_sample.xml`. Строки, в которых столбец `n_steps` заполнен, оставьте без изменений."""

import pandas as pd
import xml.etree.ElementTree as ET

# Загрузка данных из CSV файла в таблицу recipes
recipes = pd.read_csv('recipes_sample.csv')

# Выбор строк с пропусками в столбце n_steps
missing_steps = recipes[recipes['n_steps'].isnull()]

# Загрузка данных из XML файла
tree = ET.parse('steps_sample.xml')
root = tree.getroot()

# Заполнение пропусков в столбце n_steps
for recipe in root.findall('recipe'):
    recipe_id = recipe.find('id').text
    steps = recipe.findall('steps/step')
    n_steps = len(steps)
    if recipe_id in missing_steps['id'].values:
        missing_steps.loc[missing_steps['id'] == recipe_id, 'n_steps'] = n_steps

# Объединение таблиц recipes и missing_steps
recipes = pd.concat([recipes[recipes['n_steps'].notnull()], missing_steps], sort=False)

# Вывод таблицы
print(recipes)

"""3.5 Проверьте, содержит ли столбец `n_steps` пропуски. Если нет, то преобразуйте его к целочисленному типу и сохраните результаты в файл `recipes_sample_with_filled_nsteps.csv`"""

import pandas as pd

# загрузка данных
recipes = pd.read_csv('recipes_sample.csv')

# проверка на наличие пропущенных значений
if recipes['n_steps'].isnull().values.any():
    # если есть пропущенные значения, то заполняем их средним значением
    mean_n_steps = recipes['n_steps'].mean()
    recipes['n_steps'] = recipes['n_steps'].fillna(mean_n_steps)

# преобразование столбца n_steps к целочисленному типу
recipes['n_steps'] = recipes['n_steps'].astype(int)

# сохранение результатов в файл
recipes.to_csv('recipes_sample_with_filled_nsteps.csv', index=False)